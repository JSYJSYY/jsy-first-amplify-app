/** * Reads SSM environment context from a known Amplify environment variable, * fetches values from SSM and places those values in the corresponding environment variables */export const internalAmplifyFunctionResolveSsmParams = async (client) => {    const envPathObject = JSON.parse(process.env.AMPLIFY_SSM_ENV_CONFIG ?? '{}');    const paths = Object.values(envPathObject).map((paths) => paths.path);    if (paths.length === 0) {        return;    }    let actualSsmClient;    if (client) {        actualSsmClient = client;    }    else {        const ssmSdk = await import('@aws-sdk/client-ssm');        actualSsmClient = new ssmSdk.SSM();    }    const chunkArray = (array, chunkSize) => {        const chunks = [];        for (let i = 0; i < array.length; i += chunkSize) {            chunks.push(array.slice(i, i + chunkSize));        }        return chunks;    };    const resolveSecrets = async (paths) => {        const response = (await Promise.all(chunkArray(paths, 10).map(async (chunkedPaths) => await actualSsmClient.getParameters({            Names: chunkedPaths,            WithDecryption: true,        })))).reduce((accumulator, res) => {            accumulator.Parameters?.push(...(res.Parameters ?? []));            accumulator.InvalidParameters?.push(...(res.InvalidParameters ?? []));            return accumulator;        }, {            Parameters: [],            InvalidParameters: [],        });        if (response.Parameters && response.Parameters.length > 0) {            for (const parameter of response.Parameters) {                if (parameter.Name) {                    const envKey = Object.keys(envPathObject).find((key) => envPathObject[key].sharedPath === parameter.Name ||                        envPathObject[key].path === parameter.Name);                    if (envKey) {                        process.env[envKey] = parameter.Value;                    }                }            }        }        return response;    };    const response = await resolveSecrets(paths);    const sharedPaths = (response?.InvalidParameters || [])        .map((invalidParam) => Object.values(envPathObject).find((paths) => paths.path === invalidParam)?.sharedPath)        .filter((sharedParam) => !!sharedParam);     if (sharedPaths.length > 0) {        await resolveSecrets(sharedPaths);    }};await internalAmplifyFunctionResolveSsmParams();const SSM_PARAMETER_REFRESH_MS = 1000 * 60;setInterval(async () => {    try {        await internalAmplifyFunctionResolveSsmParams();    }    catch (error) {        try {                        console.debug(error);                    }        catch {                    }    }}, SSM_PARAMETER_REFRESH_MS);export {};
import{createRequire as u}from"node:module";import S from"node:path";import A from"node:url";global.require=u(import.meta.url);global.__filename=A.fileURLToPath(import.meta.url);global.__dirname=S.dirname(__filename);var c="https://api.spotify.com/v1",T=async p=>{let{accessToken:n,refreshToken:m}=p.arguments;try{let a=await fetch(`${c}/me`,{headers:{Authorization:`Bearer ${n}`}});if(!a.ok)throw new Error(`Spotify API error: ${a.status}`);let r=await a.json(),t=await(await fetch(`${c}/me/top/artists?time_range=short_term&limit=50`,{headers:{Authorization:`Bearer ${n}`}})).json(),o=await(await fetch(`${c}/me/top/tracks?time_range=short_term&limit=50`,{headers:{Authorization:`Bearer ${n}`}})).json(),f=await(await fetch(`${c}/me/player/recently-played?limit=50`,{headers:{Authorization:`Bearer ${n}`}})).json(),g=w(t,o,f),y=new Map;t.items?.forEach(e=>{e.genres?.forEach(i=>{y.set(i,(y.get(i)||0)+1)})});let h=Array.from(y.entries()).sort((e,i)=>i[1]-e[1]).slice(0,10).map(([e])=>e);return{id:`user-${r.id}`,userId:r.id,spotifyId:r.id,displayName:r.display_name,email:r.email,imageUrl:r.images?.[0]?.url||"",spotifyRefreshToken:m||"",listeningData:{topTracks:o.items?.slice(0,10).map(e=>({id:e.id,name:e.name,artists:e.artists?.map(i=>i.name)})),recentlyPlayed:f.items?.slice(0,10).map(e=>({trackId:e.track.id,trackName:e.track.name,artists:e.track.artists?.map(i=>i.name),playedAt:e.played_at})),edmGenres:g},topArtists:t.items?.slice(0,10).map(e=>({id:e.id,name:e.name,genres:e.genres,imageUrl:e.images?.[0]?.url})),topGenres:h,lastSync:new Date().toISOString(),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()}}catch(a){throw console.error("Error syncing Spotify data:",a),a}};function w(p,n,m){let a=["house","techno","trance","dubstep","bass","drum and bass","trap","hardstyle","progressive","deep house","future","tech house","melodic","minimal","acid","breaks","garage","jungle","hardcore","edm","electronic","dance","electro","ambient","downtempo"],r=new Map;p.items?.forEach(t=>{t.genres?.forEach(s=>{let o=s.toLowerCase();a.some(d=>o.includes(d))&&r.set(s,(r.get(s)||0)+3)})});let l=new Set;return m.items?.forEach(t=>{t.track.artists?.forEach(s=>{l.add(s.name)})}),{topEDMGenres:Array.from(r.entries()).sort((t,s)=>s[1]-t[1]).slice(0,10).map(([t,s])=>({genre:t,count:s})),recentlyPlayed:Array.from(l).slice(0,20).map(t=>({genre:t,count:1}))}}export{T as handler};
//# sourceMappingURL=index.mjs.map
